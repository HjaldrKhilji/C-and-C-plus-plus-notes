
Error handling is usually done well 
when done hirarchially, which is the 
case in successfull long running 
systems, and is the case with what
is supported by the exception
handling mechanism.

Now the exception handling mechanisms
hirarcheal characteristic implies that
the caller in every layer should have
context that is useful to recover the
object. The context can be a list 
containing c style  strings used to
construct c++ standard library strings, so that the strings can be recovered. The context can otherwise be freind objects, and freind objects in this case can be useful if:
The freind objects contains additional 
necessary information that is too heavy to pass to the called function. What makes freind objects special is that they can access private/protected 
members as well which is better because 
now you don't have to reconstruct 
the object for error handling. 
As always, errors that require 
context hence requiring exception
should be minimized in the first
place, but that isn't possible 
because of encapsulation which 
again is useful, but this is
one small cone of encapsulation.
Sometimes though, encapsulation
may not be the issue, may be,
the only way to fix the object 
is rebuilding it, but it is the 
issue when the solution is freind
objects.

the point that "errors requiring context"
should be minimized isn't always possible,
and sometimes make the system too complex,
hence its always good to have a eye open,
and to keep everything balanced for your
specific usecase. to do that, it takes
taste and experience.

according to bjarne streoustrup's book:
In the context of c++, errors that 
can be fixed locally by a function call,
without bothering the caller, or any of
the indirect(callers of the callers) 
callers are not to be fixed with 
exceptions, and are not seen as errors.

all of this implies that error
handling should be done requires a 
central strategy that is thought of 
in the beginning of the design process
of your system. this central strategy
is required to be consistently followed,
which inturn requires it to be
simple and explicitly implementable
,so that it can actually be consistently 
followed.without a centeal error handling
mechanism, that is thought of early,
you cant know how to balance 
encapsulations enough to not rely too 
much on exceptions while also
encapsulating enough to take advantage 
of the perks of encapsulation,
or when to use lambdas or function objects
so you can capture capture context
as opposed to functions, or when to use
function that take context as arguments
as opposed to normal functions that take
arguments useful to its task.

in c++, the noexcept specifier
makes the hirarchial even more 
visually cohesive, in that, it 
helps a layer explicitly 
state that it does not handle exceptions
from the layers that it calls, which
implies that the exception is unhandled,
hence handled by the terminate call.

A layer is a function call
in the context of this ENTIRE text, and
exceptions in general.

