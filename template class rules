($R1 23.4 ){Exactly like a class, a template class can have members of several kinds:
• Data members (variable and constant); §23.4.1
• Member functions; §23.4.2
• Member type aliases; §23.6
• static members (function and data); §23.4.4
• Member types (e.g., a member class); §23.4.5
• Member templates (e.g., a member class template); §23.4.6.3
In addition, a class template can declare friends, just as an ‘‘ordinary class’’ can; §23.4.7.
The rules for class template members are those for their generated classes. That is, if you want
to know what the rules of a template member are, just look for the rules for a member of an ordinary class (Chapter 16, Chapter 17, and Chapter 20); that will answer most
questions.
}
lets expand on what the passage above:
1.Defining non static data members: the concept is the same as ordinary classes
2.Defining non static functions: The concept is again the same, but a new non static member function is generated uniquely for every specialized type generated from the 
template when you use a non static member for that specailize type.
3.Type aliases are new for every combination of template arguments if and only if the type alias is an 
associated type(associated types(in the context of C++) are type aliases that depend on the template argument). The code for every associated type member is generated,
only if the member is used, and even then the code generated is only of the member (applies to both static and non static )functions that are used.
4.Static members in a template must be defined outside the class unless they are const/constexpr (this rule also applies to normal class), and if defined outside, then must
be defined for every specialization, if you cant do that(because there are too many specializations) then just write:
template <typename T>
int A<T>::a = 0; // Initialize a to 0 by default for all T
if the class "A" was:
template<typename T>
struct A {
    static int a;
     //structs and classes are the same thing except for the fact that struct members are public by default
};
if concepts are used and the Class "A" has the template argument that has a concept in its declaration then the static member initialization should also have that concept in 
its defintion as well, take the "std::integral" concept as an example:
if A was :
template<std::integral T>
struct A {
    static int a;
      //structs and classes are the same thing except for the fact that struct members are public by default

};
then the static member declaration must be:
template <std::integral T>
int A<T>::a = 0; // Initialize a to 0 by default for all T
template <>
int A<int>::a = 0;//overriding the default
In short, the use of concepts must match in both the declaration of a static member, and the out of class definition of that member(if any). This rule applies to 
every syntax for concepts that is provided by C++.

5.Member class templates are the same as normal class templates, but do note:
if you create a specialization using that class template member, and the template arguments passed to create that
specialization were template paremeters of the outer template class, then the resulting specialized type is a associated type.
6.friend templates classes/functions are simple, if you want a specialization(set by the arguments passed to the class who decalred them as friend) 
to be your freind:
class a{ friend void b<T>(T c);
template friend class B<T>; 
};

if you want all possible specializations of a template classs/function to be your freind, the syntax is:
template<typename C>
class B{
    
};
template<typename C>
 void f(C);
class A {
// All specializations of class B (B<int>, B<double>, etc.) are friends of A
template<typename T> friend class B; 

// All specializations of function f (f<int>, f<double>, etc.) are friends of A
template<typename T> friend void f(T a) {a.data=1;   std::cout<<a.data;} 
private:
    int data;
};
here again, the use of concepts must match in both the declaration declaring an entity as friend, and the declaration of the friend entity itself.

If you are specializing the template by passing arguments(those arguments will help resolve a template argument in this context)
to the paremeters of that template, specializing that template by 
specializing(the template argument passed for that will again specialize a new instance of the template that its a argument of)
a paremeter of that template, or any thing along those lines, and you do those things
by passing the template argument from the class declaring them as freind,then you have to write
<> after the name of the entity whose specialization you want to declare as a freind, for example:
($R1 23.4.7){
template<typename T> class Matrix;
template<typename T>
class Vector {
T v[4];
public:
friend Vector operator∗<>(const Matrix<T>&, const Vector&);
// ...
};
template<typename T>
class Matrix {
Vector<T> v[4];
public:
friend Vector<T> operator∗<>(const Matrix&, const Vector<T>&);
// ...
};
The <> after the name of the friend function is needed to make clear that the friend is a template
function. Without the <>, a non-template function would be assumed. The multiplication operator
can then be defined to access data from Vector and Matrix directly:
template<typename T>
Vector<T> operator∗(const Matrix<T>& m, const Vector<T>& v)
{
Vector<T> r;
// ... use m.v[i] and v.v[i] for direct access to elements ...
return r;
}
}
In this example we are specializing a template by 
specializing(the template argument passed for that will again specialize a new instance of that template) a paremeter of that template entity.

7.if the freind function depends on the template argument, then that friend must be a function template. This also means that the friend function's point of instantiation 
would be during the instantiation of the template class, and it would only happen if the freind function is used. 
8.The instantiation of the functions of a associated type  happens only for the used functions, and the point of instantiation for those functions would be 
during the instantiation of the outer template class.
9.The point of instantation of any member template(weather class or function) is during the instantiation of the outer template 
10. template Class member functions are inline by default if they are defined inside the class, the same rule applies to ordinary classes as well.
11. the point of instantiation of normal members that depend on the template arguments is during the instantiation of the outer template class
12. Note:the point of instantiation for template specializations is delayed by some implementations until link time, unless you use concepts. You might get 
extreamly low level error messages by the linker, but if you use concepts, you will have gurrentied compile time checks on template instantiation and compile time template
instantiation. The reason you will have template instantation (even though concepts only promise to do checks on them) is because you will be forced to provide information 
regarding the template arguments that you passed at compile time(for the compiler to do checks on template instantiation), which will
also give the compiler the information about the template arguments needed for instantiation itself, hence instantiation happens completely at compile time.
I might have used template class, class template and template function, function template interchangebly, but in the context of this document, they are the same thing.
13.static member needs only be defined for a specialization or all specializations if used.(the same rule applies to non-template classes)
14.I call normal nested(when nested in a template) classes/functions as normal instead of being templates themselves, even though they are templates is 
I do so to distinguish them from template functions and classes that take extra templete arguments other than what the outer class
already passes to them.
15.  template functions/classes can help you work between related specializations together, say a complex number template class that has two values to represent its value
can have copy constructors that are templates as well in order to allow objects from other specialization to be copied into your object. Similiarly say you had a 
template node class to be inside link lists, Now you would want the node to be generic, hence the pointer pointing to the value inside the node, can be of a template class
type that is inside your node class.($r1 23.4.6 ) is a good example. 
16. ($R1 23.4.3){Type aliases play a major role in generic programming by allowing the designer of classes to
provide common names for types in different classes (and class templates) with common semantics.}
17. virtual functons cant be templates(hence arent implicitly templates), for more information, read $B2(to find $B2, search it in the file). To me, restricting
virtual functions from getting extra arguments as a template makes snese, but not implicitly making it a template like non virtual functions dosent make sense, 
since in inheritance you can only inherit from a specialization, so the vtable mechanism can still work as long as we restrict the addition of extra arguments.
Maybe it exists for consistancy, I cant tell to be honest.
18.Inheritance($B2):
You cant inherit from a template, but rather a specialization of a template, and a virtual function in a template is not a template, so unlike other member non virtual
functions that are implicitly templates, virtual functions arent, you can still use the template arguments passed to the outer class, but the way it gets to the virtual
function isnt by it being a template itself( though that is the case with non virtual function members). This may(and is) sound odd, and also imply that out of class
definition of a virtual function can only be done for one specialization of the template, for example:
template<std::integral T>
struct A {
    static int a;
    virtual void b(); //structs and classes are the same thing except for the fact that struct members are public by default

};
template<>// you still have to write template<> since you are dealing with a member of some specialization of a template
 void A<int>::b(){//virtual isnt allowed in a out of class definition
        int a=12;
        std::cout<<a;
    } 
19.
($R1 23.4.6){
template<typename Scalar>
class complex { // old style
Scalar re, im;
public:
complex() :re(0), im(0) { }
template<typename T>
complex(T rr, T ii =0) :re(rr), im(ii) { }
complex(const complex&) = default; // copy constr uctor
template<typename T>
complex(const complex<T>& c) : re(c.real()), im(c.imag()) { }
// ...
};
complex<float> cf4 {2.1,2.9}; // ouch! narrows
complex<float> cf5 {cd}; // ouch! narrows
}
($R1 23.4.6.1 THE MAIN POINT){
To minimize the chances of confusion, I explicitly added a default copy constructor. Leaving it out
would not change the meaning of the definition: complex would still get a default copy constructor.
For technical reasons, a template constructor is never used to generate a copy constructor, so without the explicitly declared copy constructor, a default copy constructor would have been generated.
Similarly, copy assignments, move constructors, and move assignments (§17.5.1, §17.6, §19.3.1)
must be defined as non-template operators or the default versions will be generated.
}
reference:
$R1="The_C++_Programming_Language_4th_Edition_Bjarne_Stroustrup"
