($R1 23.4 ){Exactly like a class, a template class can have members of several kinds:
• Data members (variable and constant); §23.4.1
• Member functions; §23.4.2
• Member type aliases; §23.6
• static members (function and data); §23.4.4
• Member types (e.g., a member class); §23.4.5
• Member templates (e.g., a member class template); §23.4.6.3
In addition, a class template can declare friends, just as an ‘‘ordinary class’’ can; §23.4.7.
The rules for class template members are those for their generated classes. That is, if you want
to know what the rules of a template member are, just look for the rules for a member of an ordinary class (Chapter 16, Chapter 17, and Chapter 20); that will answer most
questions.
}
lets expand on what the passage above:
1.Defining non static data members: the concept is the same as ordinary classes
2.Defining non static functions: The concept is again the same, but a new non static member function is generated uniquely for every specialized type generated from the 
template when you use a non static member for that specailize type.
3.Type aliases are new for every combination of template arguments if and only if the type alias is an 
associated type(associated types(in the context of C++) are type aliases that depend on the template argument). The code for every associated type member is generated,
only if the member is used, and even then the code generated is only of the member (applies to both static and non static )functions that are used.
4.Static members in a template must be defined outside the class unless they are const/constexpr (this rule also applies to normal class), and if defined outside, then must
be defined for every specialization, if you cant do that(because there are too many specializations) then just write:
template <typename T>
int A<T>::a = 0; // Initialize a to 0 by default for all T
if the class "A" was:
template<typename T>
struct A {
    static int a;
     //structs and classes are the same thing except for the fact that struct members are public by default
};
if concepts are used and the Class "A" has the template argument that has a concept in its declaration then the static member initialization should also have that concept in 
its defintion as well, take the "std::integral" concept as an example:
if A was :
template<std::integral T>
struct A {
    static int a;
      //structs and classes are the same thing except for the fact that struct members are public by default

};
then the static member declaration must be:
template <std::integral T>
int A<T>::a = 0; // Initialize a to 0 by default for all T
template <>
int A<int>::a = 0;//overriding the default


5.Member class templates are the same as normal class templates, but do note:
if you create a specialization using that class template member, and the template arguments passed to create that
specialization were template paremeters of the outer template class, then the resulting specialized type is a associated type.
6.friend functions are the usual, but if you have a friend function template, then the syntax for that is:
 friend void b<T>(T c);
7.if the freind function depends on the template argument, then that friend must be a function template. This also means that the friend function's point of instantiation 
would be during the instantiation of the template class, and it would only happen if the freind function is used. 
8.The instantiation of the functions of a associated type  happens only for the used functions, and the point of instantiation for those functions would be 
during the instantiation of the outer template class.
9.The point of instantation of any member template(weather class or function) is during the instantiation of the outer template 
10. template Class member functions are inline by default if they are defined inside the class, the same rule applies to ordinary classes as well.
11. the point of instantiation of normal members that depend on the template arguments is during the instantiation of the outer template class
12. Note:the point of instantiation for template specializations is delayed by some implementations until link time, unless you use concepts. You might get 
extreamly low level error messages by the linker, but if you use concepts, you will have gurrentied compile time checks on template instantiation and compile time template
instantiation. The reason you will have template instantation (even though concepts only promise to do checks on them) is because you will be forced to provide information 
regarding the template arguments that you passed at compile time(for the compiler to do checks on template instantiation), which will
also give the compiler the information about the template arguments needed for instantiation itself, hence instantiation happens completely at compile time.
I might have used template class, class template and template function, function template interchangebly, but in the context of this document, they are the same thing.
13.static member needs only be defined for a specialization or all specializations if used.(the same rule applies to non-template classes)
14.I call normal nested(when nested in a template) classes/functions as normal instead of being templates themselves, even though they are templates is 
I do so to distinguish them from template functions and classes that take extra templete arguments other than what the outer class
already passes to them.
15.  template functions/classes can help you work between related specializations together, say a complex number template class that has two values to represent its value
can have copy constructors that are templates as well in order to allow objects from other specialization to be copied into your object. Similiarly say you had a 
template node class to be inside link lists, Now you would want the node to be generic, hence the pointer pointing to the value inside the node, can be of a template class
type that is inside your node class.($r1 23.4.6 ) is a good example. 
16. ($R1 23.4.3){Type aliases play a major role in generic programming by allowing the designer of classes to
provide common names for types in different classes (and class templates) with common semantics.}

Inheritance:
You cant inherit from a template, but rather a specialization of a template, and a virtual function in a template is not a template, so unlike other member non virtual
functions that are implicitly templates, virtual functions arent, you can still use the template arguments passed to the outer class, but the way it gets to the virtual
function isnt by it being a template itself( though that is the case with non virtual function members). This may(and is) sound odd, and also imply that out of class
definition of a virtual function can only be done for one specialization of the template, for example:
template<std::integral T>
struct A {
    static int a;
    virtual void b(); //structs and classes are the same thing except for the fact that struct members are public by default

};
template<>// you still have to write template<> since you are dealing with a specialization of some template
 void A<int>::b(){//virtual isnt allowed in a out of class definition
        int a=12;
        std::cout<<a;
    } 

reference:
$R1="The_C++_Programming_Language_4th_Edition_Bjarne_Stroustrup"
