Find the set of function template specializations (§23.2.2) that will take part in overload
resolution. Do this by considering each function template and deciding which template
arguments, if any, would be used if no other function templates or functions of the same
name were in scope. For the call sqrt(z), this makes sqrt<double>(complex<double>) and
sqrt<complex<double>>(complex<double>) candidates. See also §23.5.3.2.
[2] If two function templates can be called and one is more specialized than the other
(§25.3.3), consider only the most specialized template function in the following steps.
For the call sqrt(z), this means that sqrt<double>(complex<double>) is preferred over
sqrt<complex<double>>(complex<double>): any call that matches sqrt<T>(complex<T>) also
matches sqrt<T>(T).
[3] Do overload resolution for this set of functions, plus any ordinary functions, as for ordinary functions (§12.3). If a function template’s argument has been determined by template argument deduction (§23.5.2), that argument cannot also have promotions, standard
conversions, or user-defined conversions applied. For sqrt(2), sqrt<int>(int) is an exact
match, so it is preferred over sqrt(double).
[4] If a function and a specialization are equally good matches, the function is preferred.
Consequently, sqrt(double) is preferred over sqrt<double>(double) for sqrt(2.0).
[5] If no match is found, the call is an error. If we end up with two or more equally good
matches, the call is ambiguous and is an error.
step 4 causes the code below to display "a" for the two == operator uses:
#include <iostream>
#include <type_traits> 
#include<vector>
#include<functional>
template<typename B>
struct a{
    void operator==(a<B> c){
        std::cout<<"a";
    }
    
};
struct b{
    void operator==(b c){
        std::cout<<"a";
    }
    
};
template<typename B>
void operator==(B c, B d) {
        std::cout<<"b";
    }
    
int main() {
    a<int> b2;
    a<int> c;
    c==b2;//prints "a"
    b b1;
    b c1;
    b1==c1;//prints "a"
    return 0;
}
