rise of functions in the "simple dynamic dispatch pattern"(Acyclic Visitor Pattern) vs the visitor pattern:
(n*i)+1(for the node class declaration) is the grwoth of functions when a new "node"(the class on which visitor operates on) class is added or a new function is added to all nodes, n 
is the amount visitor classes plus the new one or the amount of functions plus the new one, and i is the amount(arguments of functions) of double dispatches. 
For the Acyclic Visitor Pattern it is n^i, i(arguments of functions) is the amount of double dispatchs and n is the amount of classes that already exist plus the new class.
when a new visitor class is added then nothing changes for any node class.
To recall what the visitor pattern and the "simple dynamic dispatch" method is, go to:
        The_C++_Programming_Language_4th_Edition_Bjarne_Stroustrup chapter 22

to prove my point, try adding one function or class in the example of the Acyclic Visitor Pattern( also known as the "simple dynamic dispatch"):

class Shape {

public:

virtual bool intersect(const Shape&) const =0;

virtual bool intersect(const Circle&) const =0;

virtual bool intersect(const Triangle&) const =0;

};

class Circle : public Shape {

public:

bool intersect(const Shape&) const override;

virtual bool intersect(const Circle&) const override;

virtual bool intersect(const Triangle&) const override

};

class Triangle : public Shape {

public:

bool intersect(const Shape&) const override;

virtual bool intersect(const Circle&) const override;

virtual bool intersect(const Triangle&) const override;

};

to prove me right again, try adding a single node class, node function in the Acyclic Visitor Pattern example below:
class Visitor;
class Node {
public:
virtual void accept(Visitor&) = 0;
};
class Expr : public Node {
public:
void accept(Visitor&) override;
};
class Stmt : public Node {
public:
void accept(Visitor&) override;
};
class Visitor{}
void accept(Expr&) =0;
void accept(Stmt&) =0;
;
class Do1_visitor : public Visitor {
void accept(Expr&) { cout << "do1 to Expr\n"; }
void accept(Stmt&) { cout << "do1 to Stmt\n"; }
};
class Do2_visitor : public Visitor {
void accept(Expr&) { cout << "do2 to Expr\n"; }
void accept(Stmt&) { cout << "do2 to Stmt\n"; }
};
