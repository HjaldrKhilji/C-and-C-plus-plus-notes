Rules:
A friend must be previously declared in an enclosing scope or defined in the non-class scope immediately enclosing the class that is declaring it to be a friend

The first rule states that for an entity to be recognized as a friend, it must be forward declared outside, somewhere—either in a class or in the outer namespaces. For example, 
if my friend is void N::S(), then S must be in N.

The second rule is that I can provide the definition of the friend entity right inside my class, as long as its a non member function. in this case, the non member function will be
an inline function of the enclosing namespace scope, if the class is nested inside another class, then the inline function is still a function of the enclosing namespace scope of the outer class.
for example:
class MyClass {
private:
    int secret;
public:
    // This is the *first* and only declaration of InlineFriend.
    // It's treated as an inline non-member function in the global scope.
    friend void InlineFriend(MyClass& mc) { 
        // ... access to MyClass::secret is valid here ...
    }
};

// You can call it outside the class as a normal function
// InlineFriend(...)

Additional Explanation for the First Rule ($1)
The first rule says that a name must be forward declared in the specified namespace or in the enclosing namespace. The rule, however, omits
mentioning that the name might also be declared in the namespace of the  arguments (Argument-Dependent Lookup or ADL).

example of Argument-Dependent Lookup:
class X {
friend void f(); // useless
friend void h(const X&); // can be found through its argument, also in this case it isnt a non member function in the outer namespace scope(because the second rule dosent apply here), hence
//the argument dependent lookup is very very useful, even if second rule applied, even then argument dependent lookup would be useful for finding the functions h(const X&) from a scope that is not the 
scope where h(const X&) was initially declared. This however wont apply if h(const X&) was declared as a member of a class, but that isnt the case here since we dont see: A_CLASS_NAME::h(const X&)
here
};
void g(const X& x)
{
f(); // no f() in scope
h(x); // X’s friend h()
}

An extra third rule:
Scopes outside the innermost enclosing
namespace scope are not considered for a name first declared as a friend. this third rule dosent override Argument dependent lookup describled in "Additional Explanation for the First Rule ($1)
" section.

this means that if a class A is declared in namespace N, and class b is the freind of class A then, to make the declaration of class b as a freind of class A in class A valid, class b Must be
defined in namespace N.

namespace N {

// 1. A function declared in the enclosing namespace:
void S(); // Forward declaration outside the class is done here

class MyClass {
    friend void S(); // Refers to N::S

    // 2. A friend function defined entirely inside the class body:
    friend void InlineFriend(MyClass& mc) {
        // Function body with access to private members
    }
private:
    int secret;
};

void S() {
    // Can access MyClass private members because it was declared as a friend.
}
}
However, the second rule only applies to non-member functions. For instance, InlineFriend is accessible outside the class as a non-member function. 
You  CANNOT define friend classes or friend members of classes inside your class.
thought you obviously  can define CLASSES in your class.
These two rules also imply that this code is not valid:
// 1. A function declared in the enclosing namespace:
void S(){
//definition

} // Forward declaration outside the class is done here

class MyClass {
    friend void S(); // Refers to N::S

    // 2. A friend function defined entirely inside the class body:
    friend void InlineFriend(MyClass& mc) {
        // Function body with access to private members
    }
private:
    int secret;
};


but this code is:
void S(); 

class MyClass {
private:
    int secret = 42;
public:
    // 1. Rule 1 Grant: Refers to the previously declared function S.
    friend void S(); 

    // 2. Correct Rule 2 Example: DEFINED inside the friend declaration.
    friend void InlineFriend(MyClass& mc) {
        // This definition is treated as being in the enclosing scope.
        std::cout << "Inline Friend Access: " << mc.secret << std::endl;
    }
};

// --- Correct Rule 1 Definition ---
void S() {
    // Definition must be here (outside the class) and uses the granted access.
    MyClass m;
    std::cout << "Declared Friend Access: " << m.secret << std::endl;
}

in the case of freinds that are template arguments, these rules WILL APPLY TO THOSE FREINDS TOO:
template<typename T>
class X {
friend T;
friend class T; // Note writing "class" is redundent. As you can see, i can have multiple declarations of a freind because its not a non member freind function that I was also defining
// ...
};

