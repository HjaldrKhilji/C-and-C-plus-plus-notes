Rules:
A friend must be previously declared in an enclosing scope or defined in the non-class scope immediately enclosing the class that is declaring it to be a friend

The first rule states that for an entity to be recognized as a friend, it must be forward declared outside, somewhereâ€”either in a class or in the outer namespaces. For example, 
if my friend is void N::S(), then S must be in N.

The second rule is that I can provide the definition of the friend entity right inside my class, as long as its a non member function. in this case, the non member function will be
an inline function of the enclosing namespace scope, if the class is nested inside another class, then the inline function is still a function of the enclosing namespace scope of the outer class.
for example:
class MyClass {
private:
    int secret;
public:
    // This is the *first* and only declaration of InlineFriend.
    // It's treated as an inline non-member function in the global scope.
    friend void InlineFriend(MyClass& mc) { 
        // ... access to MyClass::secret is valid here ...
    }
};

// You can call it outside the class as a normal function
// InlineFriend(...)

Additional Explanation for the First Rule
The first rule says that a name must be forward declared in the specified namespace or in the enclosing namespace. The rule, however, omits mentioning that the name might also be declared in the namespace
of the  arguments (Argument-Dependent Lookup or ADL).

An extra third rule:
Scopes outside the innermost enclosing
namespace scope are not considered for a name first declared as a friend

this means that if a class A is declared in namespace N, and class b is the freind of class A then, to make the declaration of class b as a freind of class A in class A valid, class b Must be
defined in namespace N.

namespace N {

// 1. A function declared in the enclosing namespace:
void S(); // Forward declaration outside the class is done here

class MyClass {
    friend void S(); // Refers to N::S

    // 2. A friend function defined entirely inside the class body:
    friend void InlineFriend(MyClass& mc) {
        // Function body with access to private members
    }
private:
    int secret;
};

void S() {
    // Can access MyClass private members because it was declared as a friend.
}
}
However, the second rule only applies to non-member functions. For instance, InlineFriend is accessible outside the class as a non-member function. 
You  CANNOT define friend classes or friend members of classes inside your class.
thought you obviously  can define CLASSES in your class.
These two rules also imply that this code is not valid:
// 1. A function declared in the enclosing namespace:
void S(){
//definition

} // Forward declaration outside the class is done here

class MyClass {
    friend void S(); // Refers to N::S

    // 2. A friend function defined entirely inside the class body:
    friend void InlineFriend(MyClass& mc) {
        // Function body with access to private members
    }
private:
    int secret;
};


but this code is:
void S(); 

class MyClass {
private:
    int secret = 42;
public:
    // 1. Rule 1 Grant: Refers to the previously declared function S.
    friend void S(); 

    // 2. Correct Rule 2 Example: DEFINED inside the friend declaration.
    friend void InlineFriend(MyClass& mc) {
        // This definition is treated as being in the enclosing scope.
        std::cout << "Inline Friend Access: " << mc.secret << std::endl;
    }
};

// --- Correct Rule 1 Definition ---
void S() {
    // Definition must be here (outside the class) and uses the granted access.
    MyClass m;
    std::cout << "Declared Friend Access: " << m.secret << std::endl;
}



