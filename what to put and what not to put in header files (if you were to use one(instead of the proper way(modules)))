(Note: this advice is based off what bjarne stoustrup says, so if my future me thinks otherwise, it should no that it cant be wrong until the standard of C++ or bjarne stroustrup himself says so)
Avoid header files(in favor of modules), but if you were to use one, then only use them for:
inline functions (including constexpr functions (they are always implicitly inline))
class declaration/defintions
type aliases
const/constexpr variable defintion
class/function template defintions/declarations
TEMPLATE class member functions definitions (weather its in class or not and also virtual or not)
template class member function defintions (weather its virtual or not) if they are in class
any declaration
enum/enum classes (enum classes are obviously better if you dont want to pollute the area that you include in)

what not to use them for:
Compile-time assertions static_assert(4<=sizeof(int),"small ints");
Include directives #include<algorithm>
Macro definitions #define VERSION 12.03
Conditional compilation directives #ifdef __cplusplus
Comments /∗ check for end of file ∗/
member/global function definitions char get(char∗ p) {return ∗p++; }
Data definitions int a;
Unnamed namespaces namespace { /∗ ... ∗/ }
using-directives using namespace Foo; // note i am not talking about using declarations
Aggregate definitions short tbl[] = { 1, 2, 3 };//basically the areas you see in the assembly code's data segment where chunk of data is hardcoded with some value, like
this array will probably end up being a aggregate in the assembly (if its value was hardcoded in that way (or the way that aggregates are hardcoded in some other assembly 
syntax that dosent has the data segment)). the issue:
static int large_table[] = {1, 2, 3, ... 1000};
The Linker is happy: It sees static, so it treats the array as "private" to each file. No more "Multiple Definition" errors.
Basically this applies to local/static array/struct_objects that require large intializer data.
At times, you may see the data be in text segment instead of the data segment(commonly in the case of user defined literals or large string literals), but both have the same
problems, so please avoid them in multiple translation units by including them ever where.
in fact, it is a good idea to avoid any long compile time initializer that will not be resolved at compile time
using metaprogramming, but this especially applies when using header files as we discussed.
The Binary is bloated: Every single .cpp file that includes this header now gets its own identical copy of that 1,000-element array in its data segment. 
If you include that header in 10 files, your executable size grows by the size of 10,000 integers instead of 1,000.

bjarne stroustrup's advice:
It is wise not to be too clever about the use of #include. My recommendations are:
• #include only as headers (don’t #include ‘‘ordinary source code containing variable definitions and non-inline functions’’).
• #include only complete declarations and definitions.
• #include only in the global scope, in linkage specification blocks, and in namespace definitions when converting old code (§15.2.4).
• Place all #includes before other code to minimize unintended dependencies.
• Avoid macro magic.
• Minimize the use of names (especially aliases) not local to a header in a header

The reason headers can only be used for:
inline functions (including constexpr functions (they are always implicitly inline))
class declaration/defintions
type aliases
const/constexpr variable defintion
class/function template defintions/declarations
TEMPLATE class member functions definitions (weather its in class or not and also virtual or not)
template class member function defintions (weather its virtual or not) if they are in class
any declaration
enum/enum classes (enum classes are obviously better if you dont want to pollute the area that you include in)

is because ODR(one defintion rule) allows all of them to have multiple defintions as long as:
[1] they appear in different translation units, and
[2] they are token-for-token identical, and
[3] the meanings of those tokens are the same in both translation units.
the first two of these points can be addressed using headers, but the last one is not, and to address
that, you're header should be as self contained as possible, for example:
// file1.cpp:
typedef int X;
struct S3 { X a; char b; };
// file2.cpp:
typedef char X;
struct S3 { X a; char b; }; // error
if S3 defintion was imported from an header that didnt define X(as an alias or type), then we get the error that
we get in the example above, hence, to avoid such issues, make the header self contained by defining
everything(as much as possible for your use case) in header instead of relying on the environment(file in which it is included)
for the meaning, because the error above may not be caught and such examples CAN cause undefined behaviour.
A good way to make sure that you dont mistakenly start depending on the environment is to always 
include headers in the start of your code, so that if a defintion is missing from the header, then you
dont start depending on the one in the source file that the header is included in. Infact include less reliable headers before reliable ones, and obviously the most reliable ones are standard headers.
To make sure that your header dosent depend on standard foundational headers, this technique works because
foundational headers are the most reliable.


Do note that some old code breaks some of these rules not by choice, but because they had to, for example:
For each C standard-library header <X.h>, there is a corresponding standard C++ header <cX>.
for example the short form of cstring will be:
#include<stdio.h>
while stdio.h is:
#ifdef __cplusplus // for C++ compilers only (§15.2.5)
namespace std { // the standard librar y is defined in namespace std (§4.1.2)
extern "C" { // stdio functions have C linkage (§15.2.5)
#endif
/* ... */
int printf(const char∗, ...);
/* ... */
#ifdef __cplusplus
}
}
// ...
using std::printf; // make printf available in global namespace
// ...
#endif
or maybe cstdio have all that code directly in itself, either way, we are breaking the rules by including: 
Include directives #include<algorithm>
Conditional compilation directives #ifdef __cplusplus
Comments /∗ check for end of file ∗/

These are standard headers, but they break the rules because they had no other way to do what they wanted to do in the old times.




Note that not all cstdio or stdio.h files write :using std::printf, its implementation defined


As always prefer modules instead of headers for sharing any declaration/definition in the context of any
file organization pattern for your project. Its better and you can import what ever you want, without mistakenly depending on the context.
