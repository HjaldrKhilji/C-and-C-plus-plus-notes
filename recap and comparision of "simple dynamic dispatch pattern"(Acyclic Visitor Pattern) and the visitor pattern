(NOTE: I DIDNT USE THE "BIG O() notation for being as specific as possible, but you should.")
RECAP: WHAT MAKES THESE TWO PATTERNS DIFFERENT IS THAT THE VISITOR PATTERN HAS A VISITOR CLASS HIERARCHY AND A NODE CLASS HIERARCHY, THE VISITOR CLASS HIREARCHY DOES
OPERATIONS ON THE NODE CLASS HIREARCHY, BUT THE SPECIFIC VISITOR SELECTED IS RESOLVED BY A NODE FIRST. THE "simple dynamic dispatch pattern"(Acyclic Visitor Pattern) HAS
A SINGLE HIREARCHY THAT DOES BOTH DISPATCHES IN THE DOUBLE DISPATCH ON THE OBJECTS OF THE EXACT* SAME HIERARCHY. DO NOTE THAT IN THE VISITOR PATTERN THE VISITOR AND NODE
CAN BE INFACT OF THE SAME HIREARCHY, AS LONG AS THE INTERFACE ACCEPTED BY THE NODE ISNT A BASE OF THE NODE, SO WHEN I SAY DIFFERENT HIERARCHIES, I MEAN, THE 
POINTER ARGUMENT ACCEPTED BY THE NODE FUNCTION THAT IS PERFORMING THE FIRST DYNAMIC DISPATCH SHOULD NOT IN THE SAME HIERARCHY AS THE NODE.

(n*i)+1(for the node class declaration) is the grwoth of functions when a new "node"(the class on which visitor operates on) class is added or a new function is added to all nodes, n 
is the amount visitor classes plus the new one or the amount of functions plus the new one, and i is the amount(arguments of functions) of double dispatches. 
For the Acyclic Visitor Pattern it is n^i, i(arguments of functions) is the amount of double dispatchs and n is the amount of classes that already exist plus the new class.
when a new visitor class is added then nothing changes for any node class.
To recall what the visitor pattern and the "simple dynamic dispatch" method is, go to:
        The_C++_Programming_Language_4th_Edition_Bjarne_Stroustrup chapter 22

to prove my point, try adding one function or class in the example of the Acyclic Visitor Pattern( also known as the "simple dynamic dispatch"):

class Shape {

public:

virtual bool intersect(const Shape&) const =0;

virtual bool intersect(const Circle&) const =0;

virtual bool intersect(const Triangle&) const =0;

};

class Circle : public Shape {

public:

bool intersect(const Shape&) const override;

virtual bool intersect(const Circle&) const override;

virtual bool intersect(const Triangle&) const override

};

class Triangle : public Shape {

public:

bool intersect(const Shape&) const override;

virtual bool intersect(const Circle&) const override;

virtual bool intersect(const Triangle&) const override;

};

to prove me right again, try adding a single node class, node function in the Acyclic Visitor Pattern example below:
class Visitor;
class Node {
public:
virtual void accept(Visitor&) = 0;
};
class Expr : public Node {
public:
void accept(Visitor&) override;
};
class Stmt : public Node {
public:
void accept(Visitor&) override;
};
class Visitor{}
virtual void accept(Expr&) =0; //must be virtual
virtual void accept(Stmt&) =0; //must be virtual

;
class Do1_visitor : public Visitor {
void accept(Expr&) override { cout << "do1 to Expr\n"; }
void accept(Stmt&) override { cout << "do1 to Stmt\n"; }
};
class Do2_visitor : public Visitor {
void accept(Expr&) override { cout << "do2 to Expr\n"; }
void accept(Stmt&) override { cout << "do2 to Stmt\n"; }
};
